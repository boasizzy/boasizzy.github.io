<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>回流和重绘 | boasi</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <link rel="shortcut icon" href="/favicon.ico">
  <link rel="stylesheet" href="/css/app.css">
  <!-- <link rel='stylesheet' href='http://fonts.useso.com/css?family=Source+Code+Pro'> -->
  
</head>

<body>
  <nav class="app-nav">
  
    
      <a href="/.">home</a>
    
  
    
      <a href="/archives">archive</a>
    
  
    
      <a href="/atom.xml">rss</a>
    
  
</nav>

  <main class="post">
  <article>
  <h1 class="article-title">
    <a href="/2018/10/04/%E5%9B%9E%E6%B5%81%E5%92%8C%E9%87%8D%E7%BB%98/">回流和重绘</a>
  </h1>

  <section class="article-meta">
    <p class="article-date">October 04 2018</p>
  </section>

  <section class="article-entry">
    <h3>为什么会有回流和重绘</h3>
<h4>在页面加载的时候，浏览器会把 HTML 代码解析成 DOM 树，在这个 DOM 树里面包含了所有的文本节点、元素节点和属性节点。浏览器会从根结点遍历每一个可见节点（1），，找到每个可见节点在 CSSOM 树中找到对应的规则并应用。再根据每个可见节点及其对应样式，组合成渲染树。</h4>
<h5>（1）可见的节点为：显示在渲染树上的节点（渲染书只包含显示节点）。不可见节点为 script、meta、link，或者没有通过 css 进行隐藏的节点</h5>
<h3>什么是回流</h3>
<h5>我们通过构造渲染树，我们将可见 DOM 节点以及它对应的样式结合起来可是我们还要计算它们的确切位置和大小，这个计算的阶段就是回流。</h5>
<h5>为了弄清每个 DOM 对象的大小和位置，浏览器从渲染树的根节点开始遍历，我们可以以下面这个 demo 来演示：</h5>
<pre><code>&lt;div style=&quot;width: 50%&quot;&gt;
  &lt;div style=&quot;width: 50%&quot;&gt;&lt;/div&gt;
&lt;/div&gt;
</code></pre>
<h5>我们可以看到，第一个 div 将节点的显示尺寸设置为视口宽度的 50%，第二个 div 将其尺寸设置为父节点的 50%。而在回流这个阶段，我们就需要根据视口具体的宽度，将其转为实际的像素值。</h5>
<h3>什么是重绘</h3>
<h5>最终，我们通过构造渲染树和回流阶段，我们知道了哪些节点是可见的，以及可见节点的样式和具体的信息(位置、大小)，那么我们就可以将渲染树的每个节点都转换为屏幕上的实际像素，这个阶段就叫做重绘节点。</h5>
<h4>什么时候发生回流和重绘</h4>
<h5>现在我们知道了，当页面布局发生变化的时候，就需要回流，比如以下几种情况：</h5>
<ul>
<li>添加和删除可见的 dom 元素</li>
<li>元素位置发生变化</li>
<li>元素尺寸发生变化</li>
<li>内容发生变化，比如文本变化</li>
<li>页面刚开始渲染的时候</li>
<li>浏览器窗口尺寸改变</li>
</ul>
<h5>注意：回流会触发重绘，但重绘不一定会触发回流</h5>
<h4>浏览器优化机制</h4>
<h5>由于每次重排都会造成额外的计算消耗，因此大多数浏览器都会通过队列化修改并批量执行来优化重排过程。浏览器会将修改操作放入到队列里，直到过了一段时间或者操作达到了一个阈值，才清空队列。但是！当你获取布局信息的操作的时候，会强制队列刷新。</h5>
<h3>如何减少回流和重绘</h3>
<h5>从代码优化角度考虑，我们需要减少它的发生次数，因此我们可以合并多次对 Dom 和样式的修改，然后一次处理掉。</h5>
<h5>优化前：</h5>
<pre><code>const el = document.getElementById('test');
el.style.padding = '5px';
el.style.borderLeft = '1px';
el.style.borderRight = '2px';
</code></pre>
<h5>优化后：</h5>
<pre><code>const el = document.getElementById('test');
el.style.cssText += 'border-left: 1px; border-right: 2px; padding: 5px;';
</code></pre>
<h5>或者直接改类名</h5>
<pre><code>const el = document.getElementById('test');
el.className += ' active';
</code></pre>
<h5>当我们需要对 DOM 对一系列修改的时候，可以通过以下步骤减少回流重绘次数：</h5>
<ul>
<li>使元素脱离文档流</li>
<li>对其进行多从修改</li>
<li>将元素带回文档中</li>
</ul>
<h5>该过程的第一步和第三步可能会引起回流，但是经过第一步之后，对 DOM 的所有修改都不会引起回流，因为它已经不在渲染树了。</h5>

  </section>
</article>

  <div class="sharing grid">
  <section class="profile grid-item grid">
    <img class="avatar" src="/images/tx2.jpg" alt="avatar" />
    <div class="grid-item">
      <p class="title"> boasi </p>
      <p class="subtitle">  </p>
    <div>
  </section>

  <section class="share-btns">
    <!-- <p> share it if you like it~ </p> -->
    <a
  class="twitter-share-button"
  data-size="large"
  data-via="DrakeLeung"
  href="https://twitter.com/intent/tweet?text=>为什么会有回流和重绘</h3>
<h4"
>
  Tweet
</a>

<script>
  window.twttr = (function(d, s, id) {
  var js, fjs = d.getElementsByTagName(s)[0],
    t = window.twttr || {};
  if (d.getElementById(id)) return t;
  js = d.createElement(s);
  js.id = id;
  js.src = "https://platform.twitter.com/widgets.js";
  js.async = true;
  fjs.parentNode.insertBefore(js, fjs);

  t._e = [];
  t.ready = function(f) {
    t._e.push(f);
  };

  return t;
}(document, "script", "twitter-wjs"));
</script>

  </section>
</div>


  
    
<section class="article-comment">
  <div id="disqus_thread">
    <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
  </div>
</section>

<script>
  var disqus_shortname = 'drakeleung';
  
  var disqus_url = 'http://yoursite.com/2018/10/04/%E5%9B%9E%E6%B5%81%E5%92%8C%E9%87%8D%E7%BB%98/';
  
  (function(){
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>


  
</main>

</body>
</html>
