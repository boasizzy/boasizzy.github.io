<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>原型和原型链 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <link rel="shortcut icon" href="/">
  <link rel="stylesheet" href="/css/app.css">
  <!-- <link rel='stylesheet' href='http://fonts.useso.com/css?family=Source+Code+Pro'> -->
  
</head>

<body>
  <nav class="app-nav">
  
</nav>

  <main class="post">
  <article>
  <h1 class="article-title">
    <a href="/2018/01/03/%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE/">原型和原型链</a>
  </h1>

  <section class="article-meta">
    <p class="article-date">January 03 2018</p>
  </section>

  <section class="article-entry">
    <blockquote>
<p>原型：</p>
</blockquote>
<h4>在 JavaScript 中，每当定义一个函数数据类型(普通函数、类)时候，都会天生自带一个 prototype 属性，这个属性指向函数的原型对象，并且这个属性是一个对象数据类型的值。</h4>
<pre><code>    var arr = []
    console.log(arr.__proto__)//Array
    console.log(arr.__proto__.__proto__)//Object
    //它就相当于Objcet的原型

    console.log(Object.prototype)//constructor属性返回对创建此对象的数组函数的引用
    console.log(Object.prototype.prototype)//undefined(对象)
    var d = new Date();
    console.log(d.__proto__.__proto__.__proto__)//null  一直这样找，就是原型链
    var MyArray = function(){
    }
    MyArray.prototype = new Array();
    var mine = new MyArray();
    mine.push(1,2,3);
    mine.length;

    //因为MyArray中没有push的方法，就去Array这个数组对象中去寻找，Array中也只有一个length属性，但是Array的原型中有该方法，所有push可以用，length也可以用
</code></pre>
<blockquote>
<p>原型链：</p>
</blockquote>
<h4>原型链就是利用了切换原型指向的原理，将一个构造函数的原型指向另一个构造函数的的实例对象来实现继承</h4>
<pre><code>    function Box(){
    this.name = '黎明';
    }
    function Desk(){
    this.age = 18;
    }
    let obj = new Box();
    obj.name = '小张';
    Desk.prototype = obj;
    //Desk 继承了 box，通过原型，形成了链条
    var desk = new Desk();
    desk.age = 19;
    console.log(desk.age);//19
    console.log(desk.name);//黎明
    var desk2 = new Desk();
    console.log(desk2.age);//18
    console.log(desk2.name);//小张

    &lt;!-- 自身有就用自身的，自身没有就去原型对象中寻找
    只能改变自身，不能改变原型，因为一旦改变原型，其他属性方法的原型也会被改变
    原型可以用来继承属性和方法，但是一般情况下只用来继承方法，因为属性大都不相同
    构造函数的继承就是专门用来继承实例里的属性和方法 --&gt;
</code></pre>

  </section>
</article>

  <div class="sharing grid">
  <section class="profile grid-item grid">
    <img class="avatar" src="/" alt="avatar" />
    <div class="grid-item">
      <p class="title"> Hexo </p>
      <p class="subtitle">  </p>
    <div>
  </section>

  <section class="share-btns">
    <!-- <p> share it if you like it~ </p> -->
    <a
  class="twitter-share-button"
  data-size="large"
  data-via="DrakeLeung"
  href="https://twitter.com/intent/tweet?text=ockquote>
<p>原型：</p>"
>
  Tweet
</a>

<script>
  window.twttr = (function(d, s, id) {
  var js, fjs = d.getElementsByTagName(s)[0],
    t = window.twttr || {};
  if (d.getElementById(id)) return t;
  js = d.createElement(s);
  js.id = id;
  js.src = "https://platform.twitter.com/widgets.js";
  js.async = true;
  fjs.parentNode.insertBefore(js, fjs);

  t._e = [];
  t.ready = function(f) {
    t._e.push(f);
  };

  return t;
}(document, "script", "twitter-wjs"));
</script>

  </section>
</div>


  
</main>

</body>
</html>
