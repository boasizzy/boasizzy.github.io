<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>设计模式 | boasi</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <link rel="shortcut icon" href="/favicon.ico">
  <link rel="stylesheet" href="/css/app.css">
  <!-- <link rel='stylesheet' href='http://fonts.useso.com/css?family=Source+Code+Pro'> -->
  
</head>

<body>
  <nav class="app-nav">
  
    
      <a href="/.">home</a>
    
  
    
      <a href="/archives">archive</a>
    
  
    
      <a href="/atom.xml">rss</a>
    
  
</nav>

  <main class="post">
  <article>
  <h1 class="article-title">
    <a href="/2019/06/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a>
  </h1>

  <section class="article-meta">
    <p class="article-date">June 13 2019</p>
  </section>

  <section class="article-entry">
    <blockquote>
<p>设计模式的定义：在面向对象软件设计过程中针对特定问题的简洁而优雅的解决方案</p>
</blockquote>
<h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><h4 id="单例模式的定义：保证一个类仅有一个实例，并提供一个访问它的全局访问点。实现的方法为先判断实例存在与否，如果存在则直接返回，如果不存在就创建了再返回，这就确保了一个类只有一个实例对象。"><a href="#单例模式的定义：保证一个类仅有一个实例，并提供一个访问它的全局访问点。实现的方法为先判断实例存在与否，如果存在则直接返回，如果不存在就创建了再返回，这就确保了一个类只有一个实例对象。" class="headerlink" title="单例模式的定义：保证一个类仅有一个实例，并提供一个访问它的全局访问点。实现的方法为先判断实例存在与否，如果存在则直接返回，如果不存在就创建了再返回，这就确保了一个类只有一个实例对象。"></a>单例模式的定义：保证一个类仅有一个实例，并提供一个访问它的全局访问点。实现的方法为先判断实例存在与否，如果存在则直接返回，如果不存在就创建了再返回，这就确保了一个类只有一个实例对象。</h4><h5 id="dome1"><a href="#dome1" class="headerlink" title="dome1"></a>dome1</h5><pre><code>class CreateUser {
    static shareInstance(){
        if(!CreateUser.ins){
            CreateUser.ins = new CreateUser(&apos;aa&apos;)
        }
        return CreateUser.ins;
    }
    constructor(name) {
        this.name = name;
        this.getName();
    }
    getName() {
        return this.name;
    }
}
let c1 = CreateUser.shareInstance()
let c2 = CreateUser.shareInstance()
console.log(c1==c2)</code></pre><h5 id="demo2"><a href="#demo2" class="headerlink" title="demo2"></a>demo2</h5><pre><code>let arr = [];
let arr2 = []
console.log(arr.__proto__ === arr2.__proto__)
console.log(arr==arr2)
console.log(Math)
console.log(Math == Math)
Math.random()
Math.random()
console.log(Math==Math)
//静态方法
// 实例方法
// arr.push()
// Array.from()
// Array.isArray()
class Dog{
    //统一接口
    //共享实例
    static shareInstance(){
        if(!Dog.ins){
            console.log(&apos;shareInstance 执行&apos;)
            Dog.ins = new Dog()
        }
        return Dog.ins;
    }
    constructor(){

    }
    wang(){

    }
}

let d1 = new Dog()
let d2 = new Dog()
console.log(d1==d2)

//对外提供统一的实例
let d3 = Dog.shareInstance()
let d4 = Dog.shareInstance()
let d5 = Dog.shareInstance()
console.log(d3 === d4)
console.log(d5 === d4)

class AlertView{
    static shareInstance(){

    }
    constructor(arg) {

    }
}

let a1 = AlertView.shareInstance()
a1.show({
    title:&apos;你好&apos;,
    content:&apos;测试一下&apos;,
    okCallback(){
        console.log(&apos;点了确定&apos;)
    },

    cancleCallback(){
        console.log(&apos;点了取消或者取消&apos;)

    }
})</code></pre><h3 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h3><h5 id="组合模式在对象间形成树形结构"><a href="#组合模式在对象间形成树形结构" class="headerlink" title="组合模式在对象间形成树形结构;"></a>组合模式在对象间形成树形结构;</h5><h5 id="组合模式中基本对象和组合对象被一致对待"><a href="#组合模式中基本对象和组合对象被一致对待" class="headerlink" title="组合模式中基本对象和组合对象被一致对待;"></a>组合模式中基本对象和组合对象被一致对待;</h5><h5 id="无须关心对象有多少层-调用时只需在根部进行调用"><a href="#无须关心对象有多少层-调用时只需在根部进行调用" class="headerlink" title="无须关心对象有多少层, 调用时只需在根部进行调用;"></a>无须关心对象有多少层, 调用时只需在根部进行调用;</h5><pre><code>const MacroCommand = function() {

    return {
        lists: [],
        add: function(task) {
            this.lists.push(task)
        },
        excute: function() { // ①: 组合对象调用这里的 excute,
        for (let i = 0; i &lt; this.lists.length; i++) {
            this.lists[i].excute()
        }
        },
    }
}

const command1 = MacroCommand() // 命令 1
command1.add({
    excute: () =&gt; console.log(&apos;煮咖啡&apos;) //
})

const command2 = MacroCommand() // 命令 2
command2.add({
    excute: () =&gt; console.log(&apos;打开电视&apos;)
})

command2.add({
    excute: () =&gt; console.log(&apos;打开音响&apos;)
})

const command3 = MacroCommand() //命令 3
command3.add({
    excute: () =&gt; console.log(&apos;打开空调&apos;)
})

command3.add({
    excute: () =&gt; console.log(&apos;打开电脑&apos;)
})

const macroCommand = MacroCommand()//组合对象
macroCommand.add(command1)
macroCommand.add(command2)
macroCommand.add(command3)

macroCommand.excute()

// 煮咖啡
// 打开电视
// 打开音响
// 打开空调
// 打开电脑</code></pre><h4 id="可以看出在组合模式中基本对象和组合对象被一致对待-所以要保证基本对象-叶对象-和组合对象具有一致方法。"><a href="#可以看出在组合模式中基本对象和组合对象被一致对待-所以要保证基本对象-叶对象-和组合对象具有一致方法。" class="headerlink" title="可以看出在组合模式中基本对象和组合对象被一致对待, 所以要保证基本对象(叶对象)和组合对象具有一致方法。"></a>可以看出在组合模式中基本对象和组合对象被一致对待, 所以要保证基本对象(叶对象)和组合对象具有一致方法。</h4><h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><h5 id="Observer-模式也叫观察者模式、订阅-发布模式，是由-GoF-提出的-23-种软件设计模式的一种。它也是行为模式之一，它的作用是当一个对象的状态发生变化时，能够自动通知其他关联对象，自动刷新对象状态，或者说执行对应对象的方法。"><a href="#Observer-模式也叫观察者模式、订阅-发布模式，是由-GoF-提出的-23-种软件设计模式的一种。它也是行为模式之一，它的作用是当一个对象的状态发生变化时，能够自动通知其他关联对象，自动刷新对象状态，或者说执行对应对象的方法。" class="headerlink" title="Observer 模式也叫观察者模式、订阅/发布模式，是由 GoF 提出的 23 种软件设计模式的一种。它也是行为模式之一，它的作用是当一个对象的状态发生变化时，能够自动通知其他关联对象，自动刷新对象状态，或者说执行对应对象的方法。"></a>Observer 模式也叫观察者模式、订阅/发布模式，是由 GoF 提出的 23 种软件设计模式的一种。它也是行为模式之一，它的作用是当一个对象的状态发生变化时，能够自动通知其他关联对象，自动刷新对象状态，或者说执行对应对象的方法。</h5><h5 id="这种设计模式可以大大降低程序模块之间的耦合度，便于更加灵活的扩展和维护。"><a href="#这种设计模式可以大大降低程序模块之间的耦合度，便于更加灵活的扩展和维护。" class="headerlink" title="这种设计模式可以大大降低程序模块之间的耦合度，便于更加灵活的扩展和维护。"></a>这种设计模式可以大大降低程序模块之间的耦合度，便于更加灵活的扩展和维护。</h5><h5 id="观察者模式包含两种角色："><a href="#观察者模式包含两种角色：" class="headerlink" title="观察者模式包含两种角色："></a>观察者模式包含两种角色：</h5><h6 id="观察者（订阅者）"><a href="#观察者（订阅者）" class="headerlink" title="观察者（订阅者）"></a>观察者（订阅者）</h6><h6 id="被观察者（发布者）"><a href="#被观察者（发布者）" class="headerlink" title="被观察者（发布者）"></a>被观察者（发布者）</h6><h6 id="demo1"><a href="#demo1" class="headerlink" title="demo1"></a>demo1</h6><pre><code>var obj = {
    data: {
        list: []
    },
};
// defineProperty 可以观察 obj对象 的list 属性的使用
Object.defineProperty(obj, &apos;list&apos;, {
    get() {
        console.log(&apos;获取了list 属性&apos;)
        console.log(this.data[&apos;list&apos;])
        return this.data[&apos;list&apos;]
    },
    set(val) {
        console.log(&apos;值被更改了&apos;)
        this.data[&apos;list&apos;] = val
    }
})

// 获取了list属性，那么get 方法就会被调用
console.log(obj.list)
// 设置了list属性set 方法就会被调用
obj.list = [&apos;a&apos;, &apos;b&apos;]</code></pre><h6 id="demo2-1"><a href="#demo2-1" class="headerlink" title="demo2"></a>demo2</h6><pre><code>document.addEventListener(&apos;click&apos;,function(){
    console.log(1)
})
document.addEventListener(&apos;click&apos;,function(){
    console.log(2)
})
//vue
let obj = {
    data:{
        list:[]
    }
}
//defineProperty
//给obj定义 一个属性 list
Object.defineProperty(obj,&apos;list&apos;,{
    get(){
        console.log(&apos;get list&apos;)
        return this.data.list;
    },
    set(val){
        console.log(&apos;set list&apos;,val)
        this.data.list = val
        //修改页面的dom
        // 虚拟dom  diff算法
        let ul = document.querySelector(&apos;ul&apos;)
        let arr = this.data.list.map(v=&gt;`
            &lt;li&gt;${v}&lt;/li&gt;
        `)
        ul.innerHTML = arr.join(&apos;&apos;)
    }
})

//获取list属性值的时候 会调用 get 方法
console.log(obj.list)
obj.list= [2,3];
console.log(obj.list)</code></pre><h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><h5 id="以下-demo-用代理模式来实现图片预加载-可以看到通过代理模式巧妙地将创建图片与预加载逻辑分离-并且在未来如果不需要预加载-只要改成请求本体代替请求代理对象就行。"><a href="#以下-demo-用代理模式来实现图片预加载-可以看到通过代理模式巧妙地将创建图片与预加载逻辑分离-并且在未来如果不需要预加载-只要改成请求本体代替请求代理对象就行。" class="headerlink" title="以下 demo 用代理模式来实现图片预加载, 可以看到通过代理模式巧妙地将创建图片与预加载逻辑分离, 并且在未来如果不需要预加载, 只要改成请求本体代替请求代理对象就行。"></a>以下 demo 用代理模式来实现图片预加载, 可以看到通过代理模式巧妙地将创建图片与预加载逻辑分离, 并且在未来如果不需要预加载, 只要改成请求本体代替请求代理对象就行。</h5><h5 id="js-中有事件委托-就是典型的代理模式"><a href="#js-中有事件委托-就是典型的代理模式" class="headerlink" title="js 中有事件委托 就是典型的代理模式"></a>js 中有事件委托 就是典型的代理模式</h5><h6 id="demo1-1"><a href="#demo1-1" class="headerlink" title="demo1"></a>demo1</h6><pre><code>const MyImage = function (parent) {
    const imgNode = document.createElement(&apos;img&apos;)
    parent.appendChild(imgNode)
    // 提供一个方法 ,让外部也能修改 图片的src属性
    this.setSrc = function(src){
        imgNode.src = src
    }
}
// 直接添加图片 ，如果图片比较大，可能加载的比较慢，导致网页上的img一开始显示不出来
let myImage   = new MyImage(document.body)

// 写个代理 提供 预加载功能
const ProxyImage = function (myImage) {
    // 创建image对象
    const img = new Image()
    img.on
    // 监听img对象的 onload 方法
    img.onload = function () { // http 图片加载完毕后才会执行
    // 模拟网络很慢的情况
        setTimeout(()=&gt;{
            myImage.setSrc(this.src)
        },2000)
    }

    this.setSrc =function (src) {
        // 加载时候先不加载大图，先加载一张小图（浏览器已经下载过的）
        myImage.setSrc(&apos;loading.gif&apos;) // 本地 loading 图片
        img.src = src
    }
}
let proxyImage = new ProxyImage(myImage)
proxyImage.setSrc(&apos;https://www.baidu.com/img/bd_logo1.png?where=super&apos;)</code></pre><h6 id="demo2-2"><a href="#demo2-2" class="headerlink" title="demo2"></a>demo2</h6><pre><code>const MyImage = function (parent) {
    const imgNode = document.createElement(&apos;img&apos;)
    parent.appendChild(imgNode)
    // 提供一个方法 ,让外部也能修改 图片的src属性
    this.setSrc = function(src){
        imgNode.src = src
    }
}

// 直接添加图片 ，如果图片比较大，可能加载的比较慢，导致网页上的img一开始显示不出来
let myImage   = new MyImage(document.body)

// 写个代理 提供 预加载功能
const ProxyImage = function (myImage) {
    // 创建image对象
    const img = new Image()
    img.on
    // 监听img对象的 onload 方法
    img.onload = function () { // http 图片加载完毕后才会执行
        // 模拟网络很慢的情况
        setTimeout(()=&gt;{
            myImage.setSrc(this.src)
        },2000)
    }

    this.setSrc =function (src) {
        // 加载时候先不加载大图，先加载一张小图（浏览器已经下载过的）
        myImage.setSrc(&apos;loading.gif&apos;) // 本地 loading 图片
        img.src = src
    }
}

let proxyImage = new ProxyImage(myImage)
proxyImage.setSrc(&apos;https://www.baidu.com/img/bd_logo1.png?where=super&apos;)</code></pre><h3 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h3><h5 id="适配者模式-主要用于解决两个接口之间不匹配的问题。"><a href="#适配者模式-主要用于解决两个接口之间不匹配的问题。" class="headerlink" title="适配者模式: 主要用于解决两个接口之间不匹配的问题。"></a>适配者模式: 主要用于解决两个接口之间不匹配的问题。</h5><h6 id="demo1-2"><a href="#demo1-2" class="headerlink" title="demo1"></a>demo1</h6><pre><code>// 老接口
const zhejiangCityOld = function () {
    return [{
        name: &apos;hangzhou&apos;,
        id: 11,
    },
    {
        name: &apos;jinhua&apos;,
        id: 12
    }]
}

console.log(zhejiangCityOld())
// 新接口希望是下面形式
// {
//hangzhou: 11,
//jinhua:12
// }

// 这时候就可采用适配者模式
const adaptor = function (oldCity) {
    console.log(oldCity)
    const obj = {}
    for (let city of oldCity) {
        bj[city.name] = city.id
    }
    return obj
}

let oldData = zhejiangCityOld();
//把老数据放在适配器中产生新数据
console.log(adaptor(oldData))</code></pre><h6 id="demo2-3"><a href="#demo2-3" class="headerlink" title="demo2"></a>demo2</h6><pre><code>let arr = [{
    name: &apos;hangzhou&apos;,
    id: 11,
},
{
    name: &apos;jinhua&apos;,
    id: 12
}]
let adaptorArrToObj=function(arr){
    let obj = {}
    for(let i of arr){
        obj[i.name] = i.id
    }
    return obj
}
console.log(adaptorArrToObj(arr));</code></pre><h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><h5 id="抽象工厂模式：流程-gt-先设计一个抽象类，这个类不能被实例化，只能用来派生子类，最后通过对子类的扩展实现工厂方法"><a href="#抽象工厂模式：流程-gt-先设计一个抽象类，这个类不能被实例化，只能用来派生子类，最后通过对子类的扩展实现工厂方法" class="headerlink" title="抽象工厂模式：流程=&gt; 先设计一个抽象类，这个类不能被实例化，只能用来派生子类，最后通过对子类的扩展实现工厂方法"></a>抽象工厂模式：流程=&gt; 先设计一个抽象类，这个类不能被实例化，只能用来派生子类，最后通过对子类的扩展实现工厂方法</h5><h5 id="工厂模式类似于现实生活中的工厂可以产生大量相似的商品，去做同样的事情，实现同样的效果-这时候需要使用工厂模式-js-中构造函数-都是工厂"><a href="#工厂模式类似于现实生活中的工厂可以产生大量相似的商品，去做同样的事情，实现同样的效果-这时候需要使用工厂模式-js-中构造函数-都是工厂" class="headerlink" title="工厂模式类似于现实生活中的工厂可以产生大量相似的商品，去做同样的事情，实现同样的效果;这时候需要使用工厂模式 js 中构造函数 都是工厂"></a>工厂模式类似于现实生活中的工厂可以产生大量相似的商品，去做同样的事情，实现同样的效果;这时候需要使用工厂模式 js 中构造函数 都是工厂</h5><h6 id="demo1-3"><a href="#demo1-3" class="headerlink" title="demo1"></a>demo1</h6><pre><code>//抽象类
// 抽象工厂
class DomFactory {
    constructor() {
    }

// 各流水线
insert() {
}
}

class Text extends DomFactory{
    constructor(text) {
        this.text = text;
    }
insert(where) {
    let c = document.createTextNode(this.text)
    where.appendChild(c)
}
}


let t = new Text(&apos;aaadfasdf&apos;)
t.insert(document.body)</code></pre><h6 id="demo2-4"><a href="#demo2-4" class="headerlink" title="demo2"></a>demo2</h6><pre><code>// DOM 工厂
class DomFactory {
    constructor() {
}
// 各流水线
insert() {

}
}

// 链接工厂
class Link2 extends DomFactory {
    constructor(url) {
        this.url = url
    }
    insert(where) {
        const link = document.createElement(&apos;a&apos;)
        link.href = this.url
        link.appendChild(document.createTextNode(this.url))
        where.appendChild(link)
    }
}</code></pre>
  </section>
</article>

  <div class="sharing grid">
  <section class="profile grid-item grid">
    <img class="avatar" src="/images/tx2.jpg" alt="avatar" />
    <div class="grid-item">
      <p class="title"> boasi </p>
      <p class="subtitle">  </p>
    <div>
  </section>

  <section class="share-btns">
    <!-- <p> share it if you like it~ </p> -->
    <a
  class="twitter-share-button"
  data-size="large"
  data-via="DrakeLeung"
  href="https://twitter.com/intent/tweet?text=ockquote>
<p>设计模式的定义"
>
  Tweet
</a>

<script>
  window.twttr = (function(d, s, id) {
  var js, fjs = d.getElementsByTagName(s)[0],
    t = window.twttr || {};
  if (d.getElementById(id)) return t;
  js = d.createElement(s);
  js.id = id;
  js.src = "https://platform.twitter.com/widgets.js";
  js.async = true;
  fjs.parentNode.insertBefore(js, fjs);

  t._e = [];
  t.ready = function(f) {
    t._e.push(f);
  };

  return t;
}(document, "script", "twitter-wjs"));
</script>

  </section>
</div>


  
    
<section class="article-comment">
  <div id="disqus_thread">
    <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
  </div>
</section>

<script>
  var disqus_shortname = 'drakeleung';
  
  var disqus_url = 'http://yoursite.com/2019/06/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/';
  
  (function(){
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>


  
</main>

</body>
</html>
