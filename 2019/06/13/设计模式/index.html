<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>设计模式 | boasi</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <link rel="shortcut icon" href="/favicon.ico">
  <link rel="stylesheet" href="/css/app.css">
  <!-- <link rel='stylesheet' href='http://fonts.useso.com/css?family=Source+Code+Pro'> -->
  
</head>

<body>
  <nav class="app-nav">
  
    
      <a href="/.">home</a>
    
  
    
      <a href="/archives">archive</a>
    
  
    
      <a href="/atom.xml">rss</a>
    
  
</nav>

  <main class="post">
  <article>
  <h1 class="article-title">
    <a href="/2019/06/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a>
  </h1>

  <section class="article-meta">
    <p class="article-date">June 13 2019</p>
  </section>

  <section class="article-entry">
    <blockquote>
<p>设计模式的定义：在面向对象软件设计过程中针对特定问题的简洁而优雅的解决方案</p>
</blockquote>
<h2>单例模式</h2>
<h4>单例模式的定义：保证一个类仅有一个实例，并提供一个访问它的全局访问点。实现的方法为先判断实例存在与否，如果存在则直接返回，如果不存在就创建了再返回，这就确保了一个类只有一个实例对象。</h4>
<h5>dome1</h5>
<pre><code>class CreateUser {
    static shareInstance(){
        if(!CreateUser.ins){
            CreateUser.ins = new CreateUser('aa')
        }
        return CreateUser.ins;
    }
    constructor(name) {
        this.name = name;
        this.getName();
    }
    getName() {
        return this.name;
    }
}
let c1 = CreateUser.shareInstance()
let c2 = CreateUser.shareInstance()
console.log(c1==c2)
</code></pre>
<h5>demo2</h5>
<pre><code>let arr = [];
let arr2 = []
console.log(arr.__proto__ === arr2.__proto__)
console.log(arr==arr2)
console.log(Math)
console.log(Math == Math)
Math.random()
Math.random()
console.log(Math==Math)
//静态方法
// 实例方法
// arr.push()
// Array.from()
// Array.isArray()
class Dog{
	//统一接口
	//共享实例
	static shareInstance(){
		if(!Dog.ins){
			console.log('shareInstance 执行')
			Dog.ins = new Dog()
		}
		return Dog.ins;
	}
	constructor(){

	}
	wang(){

    }
}

let d1 = new Dog()
let d2 = new Dog()
console.log(d1==d2)

//对外提供统一的实例
let d3 = Dog.shareInstance()
let d4 = Dog.shareInstance()
let d5 = Dog.shareInstance()
console.log(d3 === d4)
console.log(d5 === d4)

class AlertView{
	static shareInstance(){

    }
	constructor(arg) {

	}
}

let a1 = AlertView.shareInstance()
a1.show({
	title:'你好',
	content:'测试一下',
	okCallback(){
		console.log('点了确定')
	},

    cancleCallback(){
		console.log('点了取消或者取消')

    }
})
</code></pre>
<h2>组合模式</h2>
<h5>组合模式在对象间形成树形结构;</h5>
<h5>组合模式中基本对象和组合对象被一致对待;</h5>
<h5>无须关心对象有多少层, 调用时只需在根部进行调用;</h5>
<pre><code>const MacroCommand = function() {

    return {
        lists: [],
        add: function(task) {
            this.lists.push(task)
        },
        excute: function() { // ①: 组合对象调用这里的 excute,
        for (let i = 0; i &lt; this.lists.length; i++) {
            this.lists[i].excute()
        }
        },
    }
}

const command1 = MacroCommand() // 命令 1
command1.add({
    excute: () =&gt; console.log('煮咖啡') //
})

const command2 = MacroCommand() // 命令 2
command2.add({
    excute: () =&gt; console.log('打开电视')
})

command2.add({
    excute: () =&gt; console.log('打开音响')
})

const command3 = MacroCommand() //命令 3
command3.add({
    excute: () =&gt; console.log('打开空调')
})

command3.add({
    excute: () =&gt; console.log('打开电脑')
})

const macroCommand = MacroCommand()//组合对象
macroCommand.add(command1)
macroCommand.add(command2)
macroCommand.add(command3)

macroCommand.excute()

// 煮咖啡
// 打开电视
// 打开音响
// 打开空调
// 打开电脑
</code></pre>
<h4>可以看出在组合模式中基本对象和组合对象被一致对待, 所以要保证基本对象(叶对象)和组合对象具有一致方法。</h4>
<h2>观察者模式</h2>
<h5>Observer 模式也叫观察者模式、订阅/发布模式，是由 GoF 提出的 23 种软件设计模式的一种。它也是行为模式之一，它的作用是当一个对象的状态发生变化时，能够自动通知其他关联对象，自动刷新对象状态，或者说执行对应对象的方法。</h5>
<h5>这种设计模式可以大大降低程序模块之间的耦合度，便于更加灵活的扩展和维护。</h5>
<h5>观察者模式包含两种角色：</h5>
<h6>观察者（订阅者）</h6>
<h6>被观察者（发布者）</h6>
<pre><code>var obj = {
    data: {
        list: []
    },
};
// defineProperty 可以观察 obj对象 的list 属性的使用
Object.defineProperty(obj, 'list', {
    get() {
        console.log('获取了list 属性')
        console.log(this.data['list'])
        return this.data['list']
    },
    set(val) {
        console.log('值被更改了')
        this.data['list'] = val
    }
})

// 获取了list属性，那么get 方法就会被调用
console.log(obj.list)
// 设置了list属性set 方法就会被调用
obj.list = ['a', 'b']
</code></pre>
<h2>代理模式</h2>
<h5>以下 demo 用代理模式来实现图片预加载, 可以看到通过代理模式巧妙地将创建图片与预加载逻辑分离, 并且在未来如果不需要预加载, 只要改成请求本体代替请求代理对象就行。</h5>
<pre><code>const MyImage = function (parent) {
    const imgNode = document.createElement('img')
    parent.appendChild(imgNode)
    // 提供一个方法 ,让外部也能修改 图片的src属性
    this.setSrc = function(src){
        imgNode.src = src
    }
}
// 直接添加图片 ，如果图片比较大，可能加载的比较慢，导致网页上的img一开始显示不出来
let myImage   = new MyImage(document.body)

// 写个代理 提供 预加载功能
const ProxyImage = function (myImage) {
    // 创建image对象
    const img = new Image()
    img.on
    // 监听img对象的 onload 方法
    img.onload = function () { // http 图片加载完毕后才会执行
    // 模拟网络很慢的情况
        setTimeout(()=&gt;{
            myImage.setSrc(this.src)
        },2000)
    }

    this.setSrc =function (src) {
        // 加载时候先不加载大图，先加载一张小图（浏览器已经下载过的）
        myImage.setSrc('loading.gif') // 本地 loading 图片
        img.src = src
    }
}
let proxyImage = new ProxyImage(myImage)
proxyImage.setSrc('https://www.baidu.com/img/bd_logo1.png?where=super')
</code></pre>
<h2>适配器模式</h2>
<h5>适配者模式: 主要用于解决两个接口之间不匹配的问题。</h5>
<pre><code>// 老接口
const zhejiangCityOld = function () {
    return [{
        name: 'hangzhou',
        id: 11,
    },
    {
        name: 'jinhua',
        id: 12
    }]
}

console.log(zhejiangCityOld())
// 新接口希望是下面形式
// {
//hangzhou: 11,
//jinhua:12
// }

// 这时候就可采用适配者模式
const adaptor = function (oldCity) {
    console.log(oldCity)
    const obj = {}
    for (let city of oldCity) {
        bj[city.name] = city.id
    }
    return obj
}


let oldData = zhejiangCityOld();
//把老数据放在适配器中产生新数据
console.log(adaptor(oldData))
</code></pre>

  </section>
</article>

  <div class="sharing grid">
  <section class="profile grid-item grid">
    <img class="avatar" src="/images/tx2.jpg" alt="avatar" />
    <div class="grid-item">
      <p class="title"> boasi </p>
      <p class="subtitle">  </p>
    <div>
  </section>

  <section class="share-btns">
    <!-- <p> share it if you like it~ </p> -->
    <a
  class="twitter-share-button"
  data-size="large"
  data-via="DrakeLeung"
  href="https://twitter.com/intent/tweet?text=ockquote>
<p>设计模式的定义"
>
  Tweet
</a>

<script>
  window.twttr = (function(d, s, id) {
  var js, fjs = d.getElementsByTagName(s)[0],
    t = window.twttr || {};
  if (d.getElementById(id)) return t;
  js = d.createElement(s);
  js.id = id;
  js.src = "https://platform.twitter.com/widgets.js";
  js.async = true;
  fjs.parentNode.insertBefore(js, fjs);

  t._e = [];
  t.ready = function(f) {
    t._e.push(f);
  };

  return t;
}(document, "script", "twitter-wjs"));
</script>

  </section>
</div>


  
    
<section class="article-comment">
  <div id="disqus_thread">
    <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
  </div>
</section>

<script>
  var disqus_shortname = 'drakeleung';
  
  var disqus_url = 'http://yoursite.com/2019/06/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/';
  
  (function(){
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>


  
</main>

</body>
</html>
